
#ifndef __SYNC_MSG_CRYPT_H__
#define __SYNC_MSG_CRYPT_H__

#include <string>
#include <stdint.h>

namespace anyrtc {

static const unsigned int kAesKeySize = 32;
static const unsigned int kAesIVSize = 16;
static const unsigned int kEncodingKeySize = 43;
static const unsigned int kRandEncryptStrLen = 16;
static const unsigned int kMsgLen = 4;
static const unsigned int kMaxBase64Size = 1000000000;
enum  SyncMsgCryptErrorCode
{
    SyncMsgCrypt_OK = 0,
    SyncMsgCrypt_ValidateSignature_Error = -40001,
	SyncMsgCrypt_NULL_Error = -40002,
    SyncMsgCrypt_ComputeSignature_Error = -40003,
    SyncMsgCrypt_IllegalAesKey = -40004,
    SyncMsgCrypt_ValidateCorpid_Error = -40005,
    SyncMsgCrypt_EncryptAES_Error = -40006,
    SyncMsgCrypt_DecryptAES_Error = -40007,
    SyncMsgCrypt_IllegalBuffer = -40008,
    SyncMsgCrypt_EncodeBase64_Error = -40009,
    SyncMsgCrypt_DecodeBase64_Error = -40010,
};

class SyncMsgCrypt
{
public:
    //构造函数
    // @param sToken: 公众平台上，开发者设置的Token
    // @param sEncodingAESKey: 公众平台上，开发者设置的EncodingAESKey
    // @param sAppid: 开发者账号的appid
	SyncMsgCrypt(const std::string &sToken,
		const std::string &sEncodingAESKey,
		const std::string &sAppid)
		:m_sToken(sToken), m_sEncodingAESKey(sEncodingAESKey), m_sAppid(sAppid)
	{   }
    
    // 检验消息的真实性，并且获取解密后的明文
    // @param sMsgSignature: 签名串，对应URL参数的msg_signature
    // @param sTimeStamp: 时间戳，对应URL参数的timestamp
    // @param sNonce: 随机串，对应URL参数的nonce
    // @param sDecryptData: 密文，对应加密的数据
    // @param sMsg: 解密后的原文，当return返回0时有效
    // @return: 成功0，失败返回对应的错误码
    int DecryptMsg(const std::string &sMsgSignature,
                    const std::string &sTimeStamp,
                    const std::string &sNonce,
					const std::string &sDecryptData,
                    std::string &sMsg);
            
	//将开发者账号发送的消息加密打包
	// @param sReplyMsg:开发者账号发送的消息，xml格式的字符串
	// @param sTimeStamp: 时间戳，可以自己生成，也可以用URL参数的timestamp
	// @param sNonce: 随机串，可以自己生成，也可以用URL参数的nonce
	// @param sEncryptMsg: 加密后的可以直接回复用户的密文，包括msg_signature, timestamp, nonce, encrypt的xml格式的字符串,
	//                      当return返回0时有效
	// return：成功0，失败返回对应的错误码
	int EncryptMsg(const std::string &sReplyMsg,
		const std::string &sTimeStamp,
		const std::string &sNonce,
		std::string &sSignature,
		std::string &sEncryptMsg);

private:
    std::string m_sToken;
    std::string m_sEncodingAESKey;
    std::string m_sAppid;

private:
    // AES CBC
    int AES_CBCEncrypt( const char * sSource, const uint32_t iSize,
            const char * sKey, unsigned int iKeySize, std::string * poResult );
    
    int AES_CBCEncrypt( const std::string & objSource,
            const std::string & objKey, std::string * poResult );
    
    int AES_CBCDecrypt( const char * sSource, const uint32_t iSize,
            const char * sKey, uint32_t iKeySize, std::string * poResult );
    
    int AES_CBCDecrypt( const std::string & objSource,
            const std::string & objKey, std::string * poResult );
    
    //base64
    int EncodeBase64(const std::string sSrc, std::string & sTarget);
    
    int DecodeBase64(const std::string sSrc, std::string & sTarget);
    
    //genkey
    int GenAesKeyFromEncodingKey( const std::string & sEncodingKey, std::string & sAesKey);
    
    //signature
    int ComputeSignature(const std::string sToken, const std::string sTimeStamp, const std::string & sNonce,
        const std::string & sMessage, std::string & sSignature);
    
    int ValidateSignature(const std::string &sMsgSignature, const std::string &sTimeStamp, 
        const std::string &sNonce, const std::string & sEncryptMsg);  

    //get , set data
    void GenRandStr(std::string & sRandStr, uint32_t len);

    void GenNeedEncryptData(const std::string &sReplyMsg,std::string & sNeedEncrypt );

};

}

#endif	// __SYNC_MSG_CRYPT_H__
